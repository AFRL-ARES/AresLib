syntax = "proto3";

package ares.messaging.device;

import "google/protobuf/empty.proto";
import "CommandMetadata.proto";
import "CommandTemplate.proto";
import "CommandResult.proto";

service AresDevices {
	rpc ListAresDevices(google.protobuf.Empty) returns (ListAresDevicesResponse);
	rpc GetDeviceStatus(DeviceStatusRequest) returns (DeviceStatus);
	rpc GetCommandMetadatas(CommandMetadatasRequest) returns (CommandMetadatasResponse);
	rpc ExecuteCommand(CommandTemplate) returns (CommandResult);
}

message AresDeviceInfo {
	string name = 1; // Name of the device
}

message ListAresDevicesResponse
{
	repeated AresDeviceInfo ares_devices = 1; // collection of ares_device objects, used when all the ares devices are needed
}

message CommandMetadatasRequest {
	string device_name = 1; // device name of the device for which the commands need to be known
}

message CommandMetadatasResponse {
	repeated CommandMetadata metadatas = 1;  // list of command information supported by the requested device
}

message DeviceStatusRequest
{
	string device_name = 1; // device name of the device for which the status needs to be known
}

message DeviceStatus
{
	DeviceState device_state = 1; // the current state of the device
	string message = 2; // if the used needs to be clarified for why the state is the way it is, this message field can be used
}

enum DeviceState
{
	INACTIVE = 0; // device cannot be used as it's not connected/turned on/etc.
	ACTIVE = 1; // device is ready for action
	ERROR = 2; // device is in some error state, currently more of a placeholder until functionality is created to handle the errored devices
}